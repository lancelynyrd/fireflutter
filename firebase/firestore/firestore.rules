// FireFlutter Security Rules
//
//
// Admin UID is hard coded. This is to reduce the pricing of Firestore document read.
// It is a good idea to check the admin with custom claims.
//
// Reading a document is required to see if the user is blocked unless it is done with custom claims.
// Reading a chat room (settings) document is required when creating a new chat message.
rules_version = '2';

// ****************************** COPY FROM ***********************************
//
//
// Return true if the use is root user.
function isAdmin() {
  let adminUIDs = ['root', 'admin', 'CYKk5Q79AmYKQEzw8A95UyEahiz1', 'DiBndQah89TQu7EHUzu2hDH5gC62', 'oaCInoFMGuWUAvhqHE83gIpUxEw2', 'ZhiuNFzR4BNULdY2XvWSx5RaxGl1'];
  return request.auth.uid in adminUIDs || request.auth.token.admin == true;
}
// ****************************** COPY UNTIL HERE *****************************

service cloud.firestore {
  match /databases/{database}/documents {
    function prefix() {
      return /databases/$(database)/documents;
    }

    match /{document=**} {
      allow read, write: if false;
    }

// ****************************** COPY FROM ***********************************
    // *
    // * Belore are the FireFlutter Security Rules. Put your own rules above.
    // *


    match /users/{userDocumentId} {
      allow get: if request.auth.uid == userDocumentId || isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth.uid == userDocumentId;
      allow update: if
        isAdmin()
        ||
        ( request.auth.uid == userDocumentId && notUpdating(['disabled', 'isAdmin', 'isVerified']) )
        ||
        addOrRemove('followers', request.auth.uid) 
        // Likes are moved into rtdb by setp 16, 2023.
        // || 
        // addOrRemove('likes', request.auth.uid) 
        ;
      allow delete: if request.auth.uid == userDocumentId || isAdmin();
      match /fcm_tokens/{docId} {
      	allow read:  if (request.auth.uid == userDocumentId) || isAdmin();
        allow write: if (request.auth.uid == userDocumentId);
      }
      match /user_settings/{docId} {
      	allow read:  if (request.auth.uid == userDocumentId) || isAdmin();
        allow write: if (request.auth.uid == userDocumentId);
      }
    }


    match /user_search_data/{documentId} {
      allow read: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if request.auth.uid == documentId || isAdmin();
    }

    match /profile_view_history/{documentId} {
      allow read: if true;
      allow write: if request.resource.data.seenBy == request.auth.uid;
    }



    match /favorites/{documentId} {
      allow read, write: if resource.data.uid == request.auth.uid || request.resource.data.uid == request.auth.uid;
    }

    match /push_notification_queue/{docId} {
      allow read: if resource.data.senderUid == request.auth.uid;
      allow write: if request.resource.data.senderUid == request.auth.uid;
    }



    match /categories/{documentId} {
      allow read: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() || onlyUpdating(['noOfPosts', 'noOfComments']);
      allow delete: if isAdmin();
    }


    // Listing files/photos from storage cllection.
    match /storages/{documentId} {
      allow read: if true;
      allow create: if isAdmin() || willBeMyDoc();
      allow update: if isAdmin() || isMyDoc();
      allow delete: if isAdmin() || isMyDoc();
    }

    // Only allow write if
    // it's my post
    // only updating [likes]
    match /posts/{documentId} {

      function willBeMyPost() {
        return willBeMyDoc();
      }
      function isMyPost() {
        return isMyDoc();
      }

      allow read: if true; // Anyone should be able to read.
      allow create: if willBeMyPost();
      allow update: if 
        isMyPost()
        
        // Likes on post moved into RTDB by Sept, 16, 2023.
        // || addOrRemove('likes', request.auth.uid)
        
        || onlyUpdating(['noOfComments']);
      allow delete: if false;
    }


    match /comments/{documentId} {

      function willBeMyComment() {
        return willBeMyDoc();
      }
      function isMyComment() {
        return isMyDoc();
      }

      allow read: if true; // Anyone should be able to read comments
      allow create: if willBeMyComment();
      allow update: if isMyComment() || addOrRemove('likes', request.auth.uid);
      allow delete: if false; // Prevent hard delete in comments
    }
  

    // Master can change all the fields.
    // Moderator can only change some of the fields.
    // Chat members can only add or delete their own uid into `users` field.
    match /chats/{roomId} {
      //
      function willBeGroupChat() {
        return request.resource.data.group == true;
      }

      function willBeSingleChat() {
        return request.resource.data.group == false;
      }

      // Return true if master field is not updated.
      function notUpdatingMaster() {
        return notUpdating(['master']);
      }

      // Return true
      // - if the master is not leaving(removing) from the room.
      // - if the user does not remove the master from the room.
      function notRemovingMaster() {
        return notRemoving('users', resource.data.master);
      }


      // Return true if the user is removing himself from the room.
      function isLeaving() {
        return onlyRemoving('users', request.auth.uid);
      }

      // Return true if the user is adding himself to the room.
      function isJoining() {
        return
          onlyAddingOneElement('users')
          && 
          request.resource.data.users.toSet().difference(resource.data.users.toSet()) == [request.auth.uid].toSet();
      }

      //
      function isMaster() {
        return  resource.data.master == request.auth.uid;
      }
      function isModerator() {
        return 'moderators' in resource.data && resource.data.moderators.hasAny([request.auth.uid]);
      }
      function isRoomUser() {
        return resource.data.users.hasAny([request.auth.uid]);
      }
      function isOpen() {
        return 'open' in resource.data && resource.data.open;
      }
      // function isGroupChat() {
      //   return 'group' in resource.data && resource.data.group;
      // }

      allow read: if isRoomUser() || isOpen() || isAdmin();
      allow create: if
        required(['master', 'createdAt', 'group', 'open', 'users'])
        &&
        (
          (willBeSingleChat() && userSize() == 2) // if it's a single chat, there must be 2 members of the room.
          || 
          (willBeGroupChat() && userSize() == 1) // if it's a group, there must have only one member
        )
        &&
        // The master uid must exists in the users field.
        request.resource.data.users.hasAny([request.resource.data.master])
        &&
        // The master uid must be the creator.
        request.resource.data.master == request.auth.uid;
      
      allow update: if
        ( isMaster() && notRemovingMaster() )
        ||
        ( isModerator() && notUpdatingMaster() && notRemovingMaster() )
        ||
        isLeaving()
        ||
        ( isRoomUser() && onlyUpdating(['lastMessage', 'rename']) )
        ||
        ( isOpen() && isJoining() )
        ||
        // If the group chat is private, then users cannot invite others.
        ( isOpen() && isRoomUser() && onlyAddingOneElement('users') )
      ;

      allow delete: if false;

      match /messages/{messageId} {
        function willBeMyMessage() {
          return 'uid' in request.resource.data && request.resource.data.uid == request.auth.uid;
        }
        function isMyMessage() {
          return 'uid' in resource.data && resource.data.uid == request.auth.uid;
        }
        function roomData() {
          return get(/$(prefix())/chats/$(roomId)).data;
        }
        function isRoomUser() {
          return 'users' in roomData() && roomData().users.hasAny([request.auth.uid]);
        }

        // Check if the user is blocked for the chat room.
        // User to user blocking must be implemented in the client side ( by hiding or replacing the message as blocked ).
        function isBlocked() {
          return 'blockedUsers' in roomData() && roomData().blockedUsers.hasAny([request.auth.uid]);
        }

        allow read: if isRoomUser() && !isBlocked();
        allow create: if required(['uid']) && willBeMyMessage() && isRoomUser()  && !isBlocked();
        allow update: if isMyMessage() && !isBlocked();
        allow delete: if isMyMessage() && !isBlocked();
      }
    }


    // report
    match /reports/{documentId} {
      allow read: if isMyDoc() || isAdmin();
      allow write: if isMyDoc() || willBeMyDoc();
    }

    match /readonly/{documentId} {
      allow read: if true;
      allow write: if false;
    }


    match /rule-test-onlyUpdating/{documentId} {
      allow read: if true;
      allow update: if onlyUpdating(['a', 'b']);
    }

    match /rule-test-notUpdating/{documentId} {
      allow read: if true;
      allow update: if notUpdating(['a', 'b']);
    }
    match /rule-test-onlyRemoving/{documentId} {
      allow read: if true;
      allow update: if onlyRemoving('users', 'b');
    }
    match /rule-test-onlyAdding/{documentId} {
      allow read: if true;
      allow update: if onlyAdding('users', 'b');
    }

    /// 
    match /only-xxx/{documentId} {
      allow read: if true;
      allow create: if request.auth.uid == documentId;
      allow update: if 
        request.auth.uid == documentId
        ||
        onlyAdding('likes', request.auth.uid) // add c
        ||
        onlyRemoving('likes', request.auth.uid) // 
    }
// ****************************** COPY UNTIL HERE *****************************
  }
}

// ****************************** COPY FROM ***********************************
// * Warning : It's check the fields after save.
// * Warning : !!! It's not checking the incoming data fields !!!
// @example
// required(['master', 'createdAt', 'group', 'open', 'users'])
function required(fields) {
  return request.resource.data.keys().hasAll( fields );
}


// Returns the number of users in the room AFTER save. Count without uinique uids.
// ! After save
function userSize() {
  return request.resource.data.users.size();
}


// Returns true if only the specified fields are updated in the document.
//
// For instance, the input fields are ['A', 'B'] and if the document is updated with ['A', 'C'], then it return true.
// For instance, the input fields are ['A', 'B'] and if the document is updated with ['C', 'D'], then it return false.
function onlyUpdating(fields) {
  return request.resource.data.diff(resource.data).affectedKeys().hasOnly(fields);
}


// Returns true if the array field in the document is adding only the element.
// It must not replace any other element.
//
// Returns
// - true if the array does not exists and no other fields are updated except adding the element into the arrayField.
// - true if it try to add an element that is already in the array and no other fields are updated.
// - false if the document does not exist (especially when you put it on "update if: ...")
// - false if it is trying to add an wrong-item that is not the element.
//    - For instance, the element is "user.uid" and the user is trying to add "another user uid".
//    - For example "onlyAdding('users', 'a')" is being called but the request data is "{users: ['b']}".
//      if "onlyAdding('users', 'a')" is being called then, it can only add "a" into the "users" array.
// - false if it try to update other fields than the array field. Updating other fields are not allowed.
// * It will make a problem if it returns true when it try to add an element that is already in the array.
function onlyAdding(arrayField, element) {
  
  let oldSet = (arrayField in resource.data ? resource.data[arrayField] : []).toSet();
  let newSet = request.resource.data[arrayField].toSet();

  return
    ( !(arrayField in resource.data) && noFieldChangedExcept(arrayField) )
    ||
    ( element in oldSet && noFieldChanged() )
    ||
    (
      onlyUpdating([arrayField])
      &&  
      // anything else has deleted?
      oldSet.intersection(newSet) == oldSet
      &&
      // only the element has added?
      newSet.difference(oldSet) == [element].toSet()
    )
  ;
}


// Return true if the array field in the document is removing only the the element. It must maintain other elements.
//
// arrayField is an array
// [element] is an element to be removed from the arrayField
//
// Returns
// - true if it try to remove an element that is not existing int the array and no other fields are changed.
// - false if the document does not exsit (especially when you put it on "update if: ...").
// 
// Use case;
// Other users can add or remove only their uid from the followers array of the otehr user document
// match /users/{documentId} {
//   allow update: if request.auth.uid == documentId || onlyAdding('followers', request.auth.uid) || onlyRemoving('followers', request.auth.uid)
// }
function onlyRemoving(arrayField, element) {

  let oldSet = (arrayField in resource.data ? resource.data[arrayField] : []).toSet();
  let newSet = request.resource.data[arrayField].toSet();

  return
      ( !(arrayField in resource.data) && noFieldChangedExcept(arrayField) )
      ||
      ( !(element in oldSet) && noFieldChanged() )
      ||
      (
        onlyUpdating([arrayField])
        &&
        oldSet.difference(newSet) == [element].toSet()
        &&
        oldSet.intersection(newSet) == newSet
      )
  ;
}



// 입력된 fields 중 하나라도 업데이트 되면 false. 즉, 업데이트 안되어야 성공.
// 예) 기존: {a: 1, b: 2, c: 3}, 업데이트: {a: 10, b: 20} 인 경우, a 와 b 필드가 업데이트된다.
// 이 때, 입력 필드 fields 가 ['a', 'c'] 인 경우,
// a 와 c 필드가 업데이트 되지 않기를 원하는데, 실제로는 b 가 업데이트 되었다. 그래서, false 리턴
function notUpdating(fields) {
  return !request.resource.data.diff(resource.data).affectedKeys().hasAny(fields);
}

// Return true if the array field in the document is not removing the element.
//
// Usage: notRemoving('users', resource.data.master) - for blocking moderator to remove master.
function notRemoving(field, element) {
  return request.resource.data[field].hasAny([element]);
}





// Returns true if it adds only one element to the array field.
//
// * It allows to update other fields in the document.
//
// This must add an elemnt only. Not replacing any other element. It does unique element check.
function onlyAddingOneElement(arrayField) {
  return
    resource.data[arrayField].toSet().intersection(request.resource.data[arrayField].toSet()) == resource.data[arrayField].toSet()
    &&
    request.resource.data[arrayField].toSet().difference(resource.data[arrayField].toSet()).size() == 1
  ;
}



// Returns true if the array field in the document is adding or removing the element.
//
// * It allows to add or remove the element from the array field.
function addOrRemove(arrayField, element) {
  return onlyAdding(arrayField, element) || onlyRemoving(arrayField, element);
}



function willBeMyDoc() {
  return 'uid' in request.resource.data && request.resource.data.uid == request.auth.uid;
}

// Returns true if the user owns the document.
function isMyDoc() {
  return 'uid' in resource.data && resource.data.uid == request.auth.uid;
}

// Returns true if there is no fields that are updated except the specified field.
function noFieldChangedExcept(field) {
  return request.resource.data.diff(resource.data).affectedKeys().hasOnly([field]);
}

// Returns true if there is no fields that are updated.
function noFieldChanged() {
  return request.resource.data.diff(resource.data).affectedKeys().hasOnly([]);
}


// If the user is disabled by the admin in Firebase Auth, they cannot login and they don't have request.auth.uid.
// So, no need to check if the user is disabled.
// function isDisabled() {
//   return true;
// }
// ****************************** COPY UNTIL HERE *****************************